\documentclass{article}

\usepackage{amsmath,amssymb,amsthm,cancel,centernot,fancyhdr,ifthen,../mathwidth,stmaryrd,textgreek,ulsy,xfrac,xspace}
\usepackage[inline]{enumitem}
\usepackage[svgnames,dvipsnames]{xcolor}
\usepackage[all]{xy}


% \usepackage{infer}
% \newcommand\ib[1]{\infbox{#1}}

\usepackage[compact]{titlesec}
\titleformat{\section}
  {\normalfont\Large\bfseries}{Problem \thesection}
  {0em}{}
\newcommand{\Problem}[1][]{\ifthenelse{\equal{#1}{}}{}{\addtocounter{section}{#1}}\clearpage\section{}\setcounter{page}{1}}

\pdfpagewidth   8.5in
\pdfpageheight    11in
\setlength\paperheight {11in}
\setlength\paperwidth  {8.5in}

\setlength\parindent {0pt}
\setlength\parskip   {5pt}

%Adjust the margins
\topmargin        -0.5in
\oddsidemargin      0in
\evensidemargin     0in
\textheight       9.0in
\textwidth        6.5in

\pagestyle{fancy}
\rhead{CS:4980 Functional Algorithms / Spring 2021}
\cfoot{}
\rfoot{\thepage}

\usepackage{listings}
\lstloadlanguages{Haskell}
\lstset{
  xleftmargin=\parindent,
  basicstyle=\ttfamily\small,
  keepspaces=true,
  keywordstyle=\underbar,
  numberstyle=\tiny,
  flexiblecolumns=false,
  basewidth={0.5em,0.45em},
  morekeywords={instance, class, if, where, data, then, else, type, case, of, require, linear, primitive, do, let, in},
  morecomment=[l]{--},
  mathescape=true,
  literate={+}{{$+$}}1 {/}{{$/$}}1 {*}{{$\star$}}1 {=}{{$=$}}1
    {/=}{{$\not=$}}2
    {>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
    {\\\\}{{\bs\bs}}1 {\\"}{{\char`\\"}}2
    {->}{{$\to$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
    {:+:}{{$\oplus$}}1 {:*:}{{$\otimes$}}1 {->.}{{$\lto$}}2 {-><}{{$\SeTo$}}2 {->>}{{$\ShTo$}}2
    {!-><}{{$\labseto{!}$}}2 {!->>}{{$\labshto{!}$}}2
    {-f>}{{$\labto{\mathtt{f}}$}}2{-g>}{{$\labto{\mathtt{g}}$}}2{-h>}{{$\labto{\mathtt{h}}$}}2{-j>}{{$\labto{\mathtt{j}}$}}2{-k>}{{$\labto{\mathtt{k}}$}}2
   {-f><}{{$\labseto{\mathtt{f}}$}}2{-g><}{{$\labseto{\mathtt{g}}$}}2{-h><}{{$\labseto{\mathtt{h}}$}}2{-j><}{{$\labseto{\mathtt{j}}$}}2{-k><}{{$\labseto{\mathtt{k}}$}}2
    {-f>>}{{$\labshto{\mathtt{f}}$}}2{-g>>}{{$\labshto{\mathtt{g}}$}}2{-h>>}{{$\labshto{\mathtt{h}}$}}2{-j>>}{{$\labshto{\mathtt{j}}$}}2{-k>>}{{$\labshto{\mathtt{k}}$}}2
    {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$}}2
    {\ .\ }{{$\circ$}}3
    {\#}{{$\cdot$}}1
    {>>}{{>>}}2 {>>=}{{>>=}}3
    {|}{{$\mid$}}1
    {~~}{{$\equiv$}}1
    {/\\}{{$\land$}}1
    {++}{{$\mathtt{+\!\!\!+}$}}2
}
\lstnewenvironment{code}{}{}
\lstnewenvironment{codef}{\lstset{basicstyle=\ttfamily\small,xleftmargin=1.5em}}{}
\lstnewenvironment{codel}{\lstset{numbers=left}}{}
\newcommand\CodeSkip{\vspace{-7pt}}


\begin{document}

\Problem

Here are two definitions of the \lstinline!reverse! function in Haskell:
\begin{code}
reverse, reverse' :: [a] -> [a]
\end{code}
\CodeSkip
\begin{code}
reverse []     = []
reverse (x:xs) = reverse xs ++ [x]
\end{code}
\CodeSkip
\begin{code}
reverse' = revIter [] where
  revIter ys [] = ys
  revIter ys (x : xs) = revIter (x : ys) xs
\end{code}
Prove (by induction) that for all lists $xs$, $\texttt{reverse} \; xs = \texttt{reverse'} \; xs$.

\textit{Hint:}  The key part of your proof will be finding an invariant for the helper function \texttt{revIter}.  If it helps, you may assume the following definition of the append operator \texttt{++}:
\begin{code}
(++) :: [a] -> [a] -> [a]
\end{code}
\CodeSkip
\begin{code}
[]       ++ ys = ys
(x : xs) ++ ys = x : (xs ++ ys)
\end{code}

\Problem

The \textit{Tribonacci} numbers $T(n)$ are defined by the recurrence:
\begin{align*}
  T(0) &= 0 \\
  T(1) &= 1 \\
  T(2) &= 1 \\
  T(n) &= T(n - 1) + T(n - 2) + T(n - 3)
\end{align*}
For example, the first 10 Tribonacci numbers are:
\[
  0, 1, 1, 2, 4, 7, 13, 24, 44, 81
\]

\paragraph{Part (a).}

Consider a tree representing the recursive computation needed to compute the $n$\textsuperscript{th} Tribonacci number.  For example, for $T(5)$, we would have:
\[
\xymatrix{
 & & & T(5) \ar[dlll] \ar[d] \ar[drrr] \\
 T(2) & & & T(3) \ar[dl] \ar[d] \ar[dr] & & & T(4) \ar[dl] \ar[d] \ar[dr] \\
 & & T(0) & T(1) & T(2) & T(1) & T(2) & T(3) \ar[dl] \ar[d] \ar[dr] \\
 & & & & & & T(0) & T(1) & T(2)
}
\]
Use this tree to justify the intuition that $T(n) = O(3^n)$.

\paragraph{Part (b).} Prove, by induction, that $T(n) \leq 3^n$.  Be precise in setting up your induction hypothesis and in describing your reasoning.

\Problem

The na\"ive implementation of reverse:
\begin{code}
reverse []     = []
reverse (x:xs) = reverse xs ++ [x]
\end{code}
requires time quadratic in the length of its input list.  One way to address this is to pick a better intermediate representation of the result.  For this problem, we'll define a type \lstinline!Delt a! which represents a \emph{partially}-constructed list of type \lstinline!a!.  The idea is that a \lstinline!Delt a! transforms the \emph{remainder} of a list into an entire list; that is to say:
\begin{code}
type Delt a = [a] -> [a]
\end{code}

\paragraph{Part (a).}

Define the following operations for \lstinline|Delt|s:
\begin{itemize}

\item \lstinline|cons :: a -> Delt a -> Delt a|, which should satisfy the equation
  \[
    \mbox{\lstinline|(cons x xs) ys|} = \mbox{\lstinline|x : xs ys|}
  \]

\item \lstinline|nil :: Delt a|, which should satisfy the equation
  \[
    \mbox{\lstinline|nil ys|} = \mbox{\lstinline|ys|}
  \]

\item \lstinline|app :: Delt a -> Delt a -> Delt a|, which should satisfy the equation
  \[
    \mbox{\lstinline|(app xs ys) zs|} = \mbox{\lstinline|xs [] ++ ys zs|}
  \]
  \emph{so long as \lstinline|xs| and \lstinline|ys| are \emph{equivalent to} combinations of \lstinline|cons| and \lstinline|nil|}.
\end{itemize}

\paragraph{Part (b).}

Here is a definition of reverse in terms of \lstinline|Delt|s:
\begin{code}
reverse xs = rev xs []
    where rev [] = nil
          rev (x : xs) = app (rev xs) (cons x nil)
\end{code}
Prove that \lstinline|reverse xs| requires time linear in the length of \lstinline|xs|.  Being able to do so depends \emph{crucially} on your implementation strategy for \lstinline!app!.  In particular, if you define \lstinline|app| in terms of \lstinline|(++)|, you will (most likely) not be able to prove this property.

\Problem

A \emph{sorted stack} is a stack (that is: a data structure supporting \lstinline|push| and \lstinline|pop| operations) with the invariant that the elements on the stack are always ordered from smallest to largest.  We achieve this by modifying the usual operations as follows:
\begin{itemize}
\item \lstinline|pop| returns and removes the top item of the stack
\item \lstinline|push x| begins by removing items from the head of the stack so long as they are less than \lstinline|x|; it then adds \lstinline|x| to the head of the stack.
\end{itemize}
For example, \lstinline|push 4 [1,2,2,4,5,6]| should produce the stack \lstinline|[4,4,5,6]|

\paragraph{Part (a).}

Implement a sorted stack in Haskell by providing definitions meeting the following type signatures
\begin{code}
type SStack a = [a]
push :: Ord a => a -> SStack a -> SStack a
pop  :: Ord a => SStack a -> Maybe (a, SStack a)
\end{code}
Your implementation of \lstinline|pop| should return \lstinline|Nothing| given an empty stack.

\paragraph{Part (b).}

In the worst case, \lstinline|push| may have to traverse arbitrarily far into the stack.  However, we can show that this cost is limited over time.  Show that, \emph{starting from an empty stack}, in any sequence of \lstinline|push| and \lstinline|pop| operations each operation takes (amortized) constant time.

\Problem[3]

Consider the following scheme for implementing deletions in an (otherwise balanced) search tree:
\begin{itemize}
\item To delete an entry in the tree, instead of deleting it, simply mark it for deletion but otherwise leave the tree unchanged.
\item After marking an entry, if half (or more) of the nodes in the tree (rounded up) are marked, flatten and rebuild the tree, including only unmarked nodes.
\end{itemize}
For example, we could start from this tree:
\[
\xymatrix{
 & & & 4 \ar[dll] \ar[drr] \\
 & 2 \ar[dl] \ar[dr] & & & & 6 \ar[dl] \ar[dr] \\
 1 & & 3 & & 5 & & 7}
\]
delete 4:
\[
\xymatrix{
 & & & \xcancel 4 \ar[dll] \ar[drr] \\
 & 2 \ar[dl] \ar[dr] & & & & 6 \ar[dl] \ar[dr] \\
 1 & & 3 & & 5 & & 7}
\]
delete 3:
\[
\xymatrix{
 & & & \xcancel 4 \ar[dll] \ar[drr] \\
 & 2 \ar[dl] \ar[dr] & & & & 6 \ar[dl] \ar[dr] \\
 1 & & \xcancel 3 & & 5 & & 7}
\]
delete 6:
\[
\xymatrix{
 & & & \xcancel 4 \ar[dll] \ar[drr] \\
 & 2 \ar[dl] \ar[dr] & & & & \xcancel 6 \ar[dl] \ar[dr] \\
 1 & & \xcancel 3 & & 5 & & 7}
\]
and finally delete 5:
\[
\xymatrix{
 & 2 \ar[dl] \ar[dr] \\
 1 & & 7}
\]

Suppose that you start with a tree with $n = 2^k - 1$ elements.  Assume that you can flatten and rebuild a tree with $n$ elements in $O(n)$ time.  Use the Physicist's Method to show that, in a series of $m < n$ deletions, each deletion takes (amortized) $O(\lg n)$ time.

\Problem[2]

This problem concerns Huffman coding (and optimal prefix coding generally).

\paragraph{Part (a).}

Give an optimal prefix code (by showing the corresponding tree) for a string with the following frequencies:

\begin{tabular}{l|rrrrrrr}
  Letter & \texttt{a} & \texttt{b} & \texttt{c} & \texttt{d} & \texttt{e} & \texttt{f} & \texttt{g} \\
  \hline
  Frequency & 1 & 1 & 2 & 3 & 5 & 8 & 13
\end{tabular}

\paragraph{Part (b).}

Prove that an optimal prefix code for text with frequencies following the Fibonacci series will always have the shape you discovered in part (a).  Hint: think about the greedy step in Huffman encoding, and the corresponding property of the Fibonacci numbers.  Show this property by induction.  The shape of the tree produced by Huffman encoding follows immediately.

\end{document}
